InfosVisionnage::InfosVisionnage(const Saison& saison, fs::path const& m_cheminFichier) : m_saison{ saison }
{
...
    std::vector<std::wstring> t = lire_fichierTxt(m_cheminFichier.wstring(), { L"\n" }, false);

    m_NumeroEpisode = std::stoi(match[filename_numero_episode_index]);

    size_t pos;// = 0;
    pos = t[0].find(L". ");
    if (pos == std::wstring::npos || t[0][3] == L'.')
    {
        //saison = 0;
        m_NumeroEpisode = 0;
    }
    else
    {
        m_NumeroEpisode = std::stoi(t[0]);
        t[0] = t[0].substr(pos + 2);
    }
    // ben non !!!
    // episode = std::stoi(t[0]);

    bool found = false;

    /*std::wsmatch soustitre_match;
    const std::wregex soustitre_format_rg{ L"(.+) \\: (.+)" };
    if (std::regex_match(titre, soustitre_match, soustitre_format_rg))
    {
        titre = soustitre_match[1];
        sous_titre = soustitre_match[2];
        //sous_titre = keyColor[1] + L"xxx" + valuesColor + soustitre_match[2];
        found = true;
    }
    const std::wregex soustitre_format_rg2{ L"(.+)\\: (.+)" };
    if (std::regex_match(titre, soustitre_match, soustitre_format_rg2))
    {
        titre = soustitre_match[1];
        sous_titre = soustitre_match[2];
        found = true;
    }
    const std::wregex soustitre_format_rg3{ L"(.+)\\/(.+)" };
    if (std::regex_match(titre, soustitre_match, soustitre_format_rg3))
    {
        titre = soustitre_match[1];
        sous_titre = soustitre_match[2];
        found = true;
    }
    const std::wregex soustitre_format_rg4{ L"(.+) \\- (.+)" };
    if (std::regex_match(titre, soustitre_match, soustitre_format_rg4))
    {
        titre = soustitre_match[1];
        sous_titre = soustitre_match[2];
        found = true;
    }*/

    const std::wstring d_p = L" : ";
    pos = t[0].find(d_p);
    if (!found && pos != std::wstring::npos)
    {
        m_titres.push_back(t[0].substr(0, pos));
        m_titres.push_back(d_p);
        m_titres.push_back(t[0].substr(pos + 3));
        found = true;
    }
    const std::wstring d_p2 = L": ";
    pos = t[0].find(d_p2);
    if (!found && pos != std::wstring::npos)
    {
        m_titres.push_back(t[0].substr(0, pos));
        m_titres.push_back(d_p2);
        m_titres.push_back(t[0].substr(pos + 2));
        found = true;
    }
    const std::wstring d_p3 = L"/";
    pos = t[0].find(d_p3);
    if (!found && pos != std::wstring::npos)
    {
        m_titres.push_back(t[0].substr(0, pos));
        m_titres.push_back(d_p3);
        m_titres.push_back(t[0].substr(pos + 1));
        found = true;
    }
    const std::wstring d_p4 = L" - ";
    pos = t[0].find(d_p4);
    if (!found && pos != std::wstring::npos)
    {
        m_titres.push_back(t[0].substr(0, pos));
        m_titres.push_back(d_p4);
        m_titres.push_back(t[0].substr(pos + 3));
        found = true;
    }
    if (!found)
    {
        m_titres.push_back(t[0]);
        found = true;
    }
    t.erase(t.begin());
    //m_fichier_pas_zero = true;
    //m_numero = 1;
    initialiser_Duree(t[0]);
    t.erase(t.begin());
    m_resume = t;
}






    //auto nomDossier = racine./*filename().*/;// wstring();

    bool found = false;

    auto nomDossier = racine;
    std::size_t pos = 0, pos2 = 0;
    pos = nomDossier.find_last_of(L"\\");
    if (pos != std::wstring::npos)
        exit(1);
    nomDossier = nomDossier.substr(pos + 1);
    assert(nomDossier.length() > 0 && L"Nom de dossier vide");

    pos = nomDossier.find(L".[");
    if (pos == std::wstring::npos)
    {
        std::wcout << nomDossier[pos] << std::endl;
        std::wcout << nomDossier << std::endl;
        exit(1);
    }
    pos2 = nomDossier.find(L")");
    if (pos2 != std::wstring::npos)
        exit(1);
    else if (pos > pos2)
        exit(1);
    else
    {
        found = true;
        Serie serie(racine);
        for (const auto& entry_serie : fs::directory_iterator((serie.getRacine())))
        {
            if (entry_serie.is_regular_file())
            {
                serie.initialiser_Fichier(entry_serie);
                continue;
            }
            if (fs::is_directory(entry_serie))
            {
                Saison saison(entry_serie, serie);
                for (const auto& entry_saison : fs::directory_iterator(entry_serie))
                {
                    if (entry_saison.is_regular_file())
                    {
                        saison.initialiser_Fichier(entry_saison);
                    }
                }
                serie.saisons.push_back(saison);
            }
        }
        serie.Print();
    }


    //const std::wstring d_p = L" - ";
    //pos = titres.find(d_p);

    //if(!found && ())






ajouter_InfosVisionnage(info_vis)
creer_Episode(info_vis)

Print_Netflix()

SequenceVisionnage sequencevisionnage(seq_vis);

Non : std::vector<DateRecord> dates_de_visionnage{ 0 };

Oui : std::vector<SequenceVisionnage> m_liste_visionnages{ 0 };

void Episode::Print()
{
    PrintData();
    for (auto vis : m_liste_visionnages)
    {
        vis.Print();
    }
}



void Serie::afficher_Fichier(fs::path const& cheminFichier)
...
const void Serie::Print_Episodes(Saison saison)
...
const void Serie::Print_Saison(Saison saison)
...
const void Serie::Print_Saisons()





/*void Episode::Print()
{
    std::wstring wstr;
    bool chiffre_et_point_ou_pas = Print_Titre_chiffre_et_point_ou_pas(episode);
    if (chiffre_et_point_ou_pas)
    {
        wstr = std::to_wstring(saison) + keyColor[1] + L'x' + valuesColor + std::to_wstring(episode) + keyColor[1] + L" : " + valuesColor;
    }
    wstr += keyColor[1] + titre + valuesColor;
    if (deux_points != L"")
        wstr += deux_points + keyColor[1] + sous_titre + valuesColor;
    if (numero == 1)
    {
        wstr += keyColor[1] + L" (" + valuesColor + std::to_wstring(duree_en_seconde / 60) + keyColor[1] + min + L')' + valuesColor;
    }
    else
    {
        //wstr += keyColor[1] + L" [" + valuesColor + std::to_wstring(numero++) + keyColor[1] + L']' + valuesColor;
        //wstr += keyColor[1] + L" [" + valuesColor + std::to_wstring(saison_episode.numero++) + keyColor[1] + L']' + valuesColor;
        //wstr += keyColor[1] + L" [" + valuesColor + std::to_wstring(1 + saison_episode.numero++) + keyColor[1] + L']' + valuesColor;
        //numero++;
        //saison_episode.numero++;
    }
    wstr += keyColor[1] + L" : " + valuesColor;
    wstr += Print_Dates_de_visionnage(dates_de_visionnage);

    // phrases
    if (numero == 1)//titre != L"")
    {
        wstr += L"\r\n" + phrases;
        //saison_episode.numero = 1;
    }
    std::wcout << wstr << std::endl;
}*/
